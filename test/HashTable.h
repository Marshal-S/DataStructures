//
//  HashTable.h
//  test
//
//  Created by Marshal on 2020/8/21.
//  Copyright © 2020 Marshal. All rights reserved.
//  散列表（哈希表）

#ifndef HashTable_h
#define HashTable_h

/*
 其存在是为了提高查找效率的。--例如：要从10000查找一个学生的身份证号码为xxx的，如果普通数组只能一个一个遍历，如果把号码设置成了哈希表键值，可直接定位到目标位置查找
 装填因子0 < α < 1，表示装填的数据占总共大小的百分比，小了控件浪费，多了容易冲突查找效率变低，一般0.6~0.9是比较好的
 1.散列储存实现了关键字到地址的转化，其构成的散列的线性表成为散列表或者哈希表
 2.散列函数设计常用方法：
    数字分析法：根据使用的数字特征，取出不重复的几位作为关键字，使其分布均匀更具备唯一性，例如：3412 3422 3434 可以使用后两位作为关键字，哈希表长度100
    除留余数法(取余法):通过取余数来使其分布均匀，选择合适的除数p更为重要，一般取质数(n < p < m，其中n为要储存元素个数，m为散列表长度)， 比较常见
    平方取中法：对数值平方，取中间几位的方法，适合单个位数取值不均匀的情况（数字重复率高），比较常见
    折叠法：对关键字从左往右按一定长度进行拆分成几组，然后相加取等长位数的关键字，适用于储存数字较长的情况。例如：1234343535 哈希表长度1000 则分为 123 434 353 5 然后相加取三位数即可：即储存的关键字为915
 3.解决冲突的方法：
 （1）开放地址法则： 线性表的每一项都是储存结果的
    线性探测法：通过上面储存方法hash(key)存放散列表，发现冲突，则顺着哈希表长度加一，查看是否是空值，如果是插入该值即可，可以把该散列表看成一个环，在从冲突节点处从后找回到冲突位置即可；查找的时候，如果冲突则开始往后一个一个对比发现一样则结束，否则一直找回到冲突点，找不到结束，表示没有该值
    双散列函数探测法：通过上面储存方法hash(key)存放散列表，发现冲突，则训着哈希表长度加上rehash(key)开始查找，也是散列表看成一个环一直找到空的放进去就行，res = (a + i * b) % m,其中a为生成的关键字，b为设置冲突查找间隔(一般为质数)，i为累加查找的变量，m为散列表长度, （注意：从这个公式可以看出线性探测法只不过是b = 1的一种情况而已）
  （2）链地址法：线性表的每一项都是储存指针的，通过上面储存方法hash(key)存放散列表，不过每一项都是一个链表指针，一旦设置的key存放时发现有值冲突，则顺着存放到当前值的后面形成一个链状结构，结构可以参考邻接表的的样式， 哈希表的每一项都有可能是一个单链表（也就意味着定位到索引后直接向下查找即可，找不到就是没有），这种结构比较优化
 */

//通过上面的部分描述是不是发现之前写的计数排序和基数排序中间的存储结构和散列表很相似呢
//散列函数的常用关键字函数设计方案
void numAnaliseWay(void); //数字分析法
void divideResidueWay(void); //取余法
void powMiddleWay(void); //平方取中法
void foldingWay(void); //折叠法

//冲突解决方案
void crashLineWay(void); //线性探测法,双三列函数探测法
void crashLinkWay(void); //链地址法


#endif /* HashTable_h */
